# 원시 값과 객체의 비교

JS는 왜 구지 원시 타입과 객체 타입을 나눠 놓는 것일까?   
그 만큼 메모리를 사용하는 방식이 다르기 때문이다. 오늘은 두 타입이 메모리를 어떤 식으로 사용하는지 알아보도록 하자.

# 1. 원시 값
## 1-1. 원시 값의 특징
원시 값의 특징은 다음과 같다.   

```
    1. 메모리에 실제 값이 저장되는 형태다.
    2. 메모리에 저장된 원시 값은 절대! 변경 할 수 없다.

```
## 1-2. 원시 값을 갖는 변수의 특징

그렇다면 이러한 원시 값을 갖는 변수는 변수 값을 변경할 수 없는 건가?   
정답은 아니오다. 메모리에 할당 된 원시 값을 변경할 수는 없지만 새로운 메모리에 새로운 값을 저장한 뒤,
해당 변수에 재할당 하면 변수 값은 바뀔 수 있다. 중요한 건 메모리에 한번 저장된 원시 값은 바뀌지 않는다는 것이다.   
**그래서 변수 값의 재할당이라는 표현을 쓴다.   

이를 값의 불변성이라 한다. JS 변수의 신뢰성을 위해 이러한 방식을 채택한 것이다.
다음 예제를 보자. 원시값을 갖고 있는 변수를 다른 변수가 참조하게 된다면 어떻게 될까?

```javascript

    let score = 80;
    let copy = score;

    console.log(score); // 80
    console.log(copy);  // 80
    console.log(score === copy);    // true

    // score 변수와 copy 변수는 다른 메모리 공간에 저장된 별개의 값이다.
    // 따라서 score 변수의 값을 변경해도 copy 변수의 값에는 어떠한 영향도 주지 않는다.

    score = 100;

    console.log(score); // 100
    console.log(copy);  // 80 
    console.log(score === copy);    // false

    // 중점은 변수에 변수를 할당했을 때 무엇이 전달되는가.
    // -> 값에 의한 전달.

```
   
이렇게 JS 변수는 각 변수의 불변성과 독립성을 보장 받는다. 아무리 다른 변수들을 구워 삶아도,
해당 변수에 재할당을 하기 전까지 해당 변수 값은 변하지 않는다.   
   
** 원시 값은 메모리에 한번 저장되면 절대 바뀌지 않으며 변수 값이 바뀔 때도 마찬가지다.   
   
원시 값이 저장된 메모리를 두 개 이상의 변수가 참조할 수 있느냐에 대한 얘기를 해보자.
이는 각 브라우저가 채택한 엔진마다 다르다. 각 변수마다 절대적으로 다른 메모리를 참조하게 하는 엔진이 있는가 하면,
변수가 변수를 참조할 때는 재할당이 이뤄지기 전까지 같은 주소를 참조하는 엔진도 있다.   
결국 변수끼리 서로의 값을 간섭할 수 없는 건 확실한 사실이다.
   
   
# 2. 객체
일단 객체에 대해 다시 설명하자면 0개 이상의 프로퍼티로 구성된 값이다. 흔히 해쉬 테이블(hash table) 구조라고 하는데 JS의 객체는 해쉬 테이블과는 조금 다르다.
클래스 기반의 프로그램 언어와는 달리 클래스 없이 객체를 생성할 수 있으며, 객체가 생성된 이후에도 동적으로 프로퍼티를 제어할 수 있다.   
   
이게 가능하기 위해서는 동적 탐색, V8엔진 이후 부터는 히든 클래스 방식을 사용하는데, 히든 클래스 방식은 조금 낫다지만 동적 탐색은 상당히 메모리 사용이 많은 방식이다.   

이제 원시값과의 차이점을 이야기 해보면 원시값이 메모리에 값이 직접 저장되는 형태라면 객체는 메모리에 객체가 저장된 주소가 저장되는 형식이다.   
객체는 복잡한 자료구조이고, 이걸 메모리마다 하나씩 저장하면 컴퓨터 스트레스 받는다.
그래서 객체를 한 군데에 저장하고, 해당 객체를 사용하는 모든 변수는 객체가 저장된 주소를 변수 값으로 할당받는 방식을 채택한 것이다.   
원시값과 같은 불변성을 보장 받을 수 없는 궁여지책이지만, 메모리에 저장된 객체의 값을 변경할 수 있다는 유연성을 보장 받았다.
    
## 2-1. 객체의 특징
객체의 특징은 다음과 같다.

```

    1. 메모리에 저장된 객체는 메모리 주소를 참조하여 접근할 수 있다.
    2. 메모리에 저장된 객체 값은 변경 할 수 있다.
    3. 메모리에 저장된 객체는 여러 변수가 동시에 참조할 수 있다.

```
## 2-2. 객체 값을 갖는 변수의 특징
위에서 말했다시피 객체 값은 저장된 메모리 주소를 참조하여 직접 값을 변경할 수 있다.   
**한 마디로 해당 객체의 메모리 주소를 변수 값으로 할당한 변수는 해당 객체의 값을 직접 바꿀 수 있다.   
   
```javascript
    // 할당이 이뤄지는 시점에 객체 리터럴이 해석되고, 그 결과 객체가 생성된다.
    let person = {
        name : 'Lee'
    };

    // person 변수에 저장되어 있는 참조 값으로 실제 객체에 접근한다.
    console.log(person);    // {name: "Lee"}

    // 프로퍼티 값 갱신
    person.name = 'Kim';

    // 프로퍼티 동적 생성
    person.address = 'Seoul';

    console.log(person);    // {name: "Kim", address: "Seoul"}
    // 변수 person은 처음에 할당 받은 참조값을 그대로 가지고 있다.
```
   
객체는 이러한 구조 탓에 여러 부작용을 갖고 있다. 그중 가장 두드러지는 것은 여러 개의 식별자가 하나의 객체를 공유할 수 있다는 것이다.
   
```javascript
    let person = {
     name : 'Lee'
    };

    // 참조 값을 복사 (얕은 복사)
    let copy = person;

    // copy와 person은 동일한 객체를 참조한다.
    console.log(person === copy);   // true

    // copy를 통해 객체를 변경한다.
    copy.name = 'Kim';

    // person을 통해 객체를 변경한다.
    person.address = 'Seoul';

    // copy와 person은 동일한 메모리를 참조한다.
    // 따라서 어느 한 쪽에서 객체를 변경하면 서로 영향을 주고받는다.
    console.log(person);    // {name: "Kim", address: "Seoul"}
    console.log(copy);      // {name: "Kim", address: "Seoul"}
```