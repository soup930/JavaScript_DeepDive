# 스코프(Scope)

스코프를 쉽게 설명하면 이렇다. JS에서 객체의 생명 주기, 혹은 유효 범위를 스코프(Scope)라 칭한다.   
해당 변수, 혹은 함수를 어느 지점까지 참조할 수 있는지를 나타내는 범위이다.
가령 매개변수의 경우 해당 함수 내에서만 스코프가 지정된다.
   

```javascript

    let add = function(x, y) {
        // 매개변수는 함수 몸체 내부에서만 참조할 수 있다.
        // 즉, 매개변수의 스코프(유효범위)는 함수 몸체 내부다.
        console.log(x, y);  // 2 5
        return x + y;
    };

    add(2, 5);

    // 매개변수는 함수 몸체 내부에서만 참조할 수 있다.
    // console.log(x, y);  // Uncaught ReferenceError: x is not defined

```
   

변수는 자신이 선언된 위치에 의해 변수 자신을 참조할 수 있는 유효 범위, 즉 스코프가 결정된다. 
변수 뿐만 아니라 모든 식별자가 그렇다. 이를 스코프라 한다. **즉, 스코프는 식별자가 유효한 범위를 말한다.**
   

```javascript
    // var 변수의 스코프
    var var1 = 1;   // 코드의 가장 바깥 영역에서 선언한 변수

    if (true) {
        var var2 = 2;   // 코드 블록 내에서 선언한 변수
        if (true) {
            var var3 = 3;   // 중첩된 코드 블록 내에서 선언한 변수
        }
    }

    function foo() {
        var var4 = 4;   // 함수 내에서 선언한 변수

        function bar() {
            var var5 = 5;   // 중첩된 함수 내에서 선언한 변수
        }
    }

    console.log(var1);  // 1
    console.log(var2);  // 2
    console.log(var3);  // 3
    // console.log(var4);  // Uncaught ReferenceError: var4 is not defined
    // console.log(var5);  // Uncaught ReferenceError: var5 is not defined
```
   

위의 예제는 함수 블록 스코프를 갖는 var 선언문의 문제점을 적나라하게 드러내고 있다. 
함수가 이외의 블록에서는 스코프를 따로 생성하지 않는 게 var 변수의 문제점이다.   

그렇다면 같은 식별자 이름으로 여러개의 스코프를 갖는 것이 가능할까?
   
   
```javascript
    let x = 'global';

    function foo() {
        let x = 'local';
        console.log(x);
    }

    foo();

    console.log(x);
```
   

쌉가능. 똑같은 식별자(변수 명)를 가진 변수 x 이지만, 함수 밖에 선언 된 x는 'global' 값을 갖는 '전역 스코프'를, 
foo 함수 안에 선언 된 x는 'local' 값을 갖는 '지역 스코프'를 각각 갖게 되었다.   

**즉, 똑같은 변수 명이지만 각각 다른 스코프를 갖는 별개의 변수 2개가 만들어진 것이다.**   

똑같은 식별자이지만 문맥에 따라 JS 엔진은 어떤 변수를 참조할지를 결정한다. **이를 식별자 결정(identifier resolution)이라 한다.**   

결국 스코프란 JS 엔진이 식별자를 검색할 때 사용하는 규칙이라고 할 수 있다.
   

## 스코프의 종류

위의 예제에서도 언급됬지만 스코프는 '전역 스코프'와 '지역 스코프'로 나뉜다.   
변수를 가지고 예를 들자면, 블록이나 함수가 아닌 코드 가장 바깥 영역에 선언되는 변수가 전역 스코프를 가지는 전역 변수. 
함수 몸체 내부나(var) 블록 내부에(let, const) 선언되는 변수가 지역 스코프를 가지는 지역 변수이다.
   
같은 식별자명으로 전역 스코프와 지역 스코프가 동시에 있다면 JS 엔진은 어떤 변수를 참조할까? 
만약 두 스코프가 동시에 있는 상황이라면 전역 스코프보다 지역 스코프를 더 우선적으로 참조한다. 이러한 동작 방식은 스코프 체인과 큰 연관이 있다.
   

## 스코프 체인 (Scope chain)

전역 변수명과 지역 변수명이 같은 경우가 있다. 혹은 함수 내에 또 다른 내부 함수가 있고 내부 함수 내에 또 다른 지역 변수가 존재 할 수도 있다.   
이런 식으로 같은 식별자를 가진 스코프가 무한이 중첩될 수 있다. 이런 경우 스코프는 이러한 단방향 계층 관계를 형성한다.
   

```
    전역 스코프 -> 지역 스코프 -> 지역의 지역 스코프 -> ... -> 최하위 지역 스코프
```
   

**이렇게 스코프가 계층적으로 연결될 것을 스코프 체인(Scope chain)이라 한다.**   

JS 엔진은 코드를 실행하기에 앞서 이러한 계층형 자료구조인 렉시컬 환경(Lexical Environment)라는 환경을 실제로 생성한다. 
변수 선언이 실행되면 변수 식별자가 이 렉시컬 환경에 키(key)로 등록되고 할당된 변수 값도 여기에서 변경한다.

그리고 변수를 참조할 때도 렉시컬 환경에서 검색이 이뤄진다. JS 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다.   

이를 통해 지역 스코프가 전역 스코프보다 우선적으로 참조되며, 지역 스코프가 해당 블록에 없을 경우 전역 스코프를 참조하는 방식이 가능한 것이다.   

물론 단방향 계층 관계이기 때문에 하위 스코프에서 상위 스코프를 참조하는 건 가능하지만 상위 스코프에서 하위 스코프를 참조하는 건 불가능하다.
   

```javascript

    // 전역 함수
    function foo() {
        console.log('global function foo');
    }

    function bar() {
        // 중첩 함수
        function foo() {
            console.log('local function foo');
        }

        foo();
    }

    bar();  // local function foo

```
   

## 함수 레벨 스코프

코드 블록이 아닌 함수에 의해서만 지역 스코프가 생성되는 것을 말한다. 
var 키워드로 변수를 선언 할 경우 이러한 스코프 생성 규칙을 따르게 되는데 이는 var 키워드의 큰 단점으로 꼽힌다.
   
if문이나 for문 같은 연산자들의 블록에서는 지역 스코프가 생성되지 않고, 오직 함수 블록 내부에서만 지역 스코프가 생성되는 것이다.
   

```javascript

     var x = 1;

    if (true) {
        // var 키워드로 선언된 변수는 함수의 코드 블록(함수 몸체)만을 지역 스코프로 인정한다.
        // 함수 밖에서 var 키워드로 선언된 변수는 코드 블록 내에서 선언되었다 할지라도 모두 전역 변수다.
        // 따라서 x는 전역 변수다. 이미 선언된 전역 변수 x가 있으므로 x 변수는 중복 선언된다.
        // 이는 의도치 않게 변수 값이 변경되는 부작용을 발생시킨다.
        var x = 10;
    }

    console.log(x);     // 10

```
   

## 렉시컬 스코프 (Lexcial scope)

예제를 한번 보자.
   

```javascript
    var x = 1;

    function foo() {
        var x = 10;
        bar();
    }

    function bar() {
        console.log(x);
    }

    foo();  // 1
    bar();  // 1
```
   

렉시컬 스코프(Lexical scope)는 정적 스코프라고도 불린다. JS는 이러한 렉시컬 스코프 방식을 따른다.
위에서 설명했다시피 스코프는 미리 만들어진 렉시컬 환경에 식별자가 선언될 때 만들어진다고 했다.
   
**즉, 스코프는 식별자가 선언되는 시점에 미리 만들어져 있다는 것이다.**
   
위의 예제를 보면 두 함수 모두 전역 변수 x의 값인 1을 내뱉고 있다. foo() 함수에서 지역 변수를 선언한고 값도 10으로 할당했지만 전혀 참조되지 않았다.
   
이는 bar() 함수 내부에서 참조하는 x의 값이 이미 bar() 함수가 선언될 때 정해졌기 때문이다. 
bar() 함수에는 x라는 지역 스코프가 없으니, 같은 식별자를 가진 전역 스코프의 값을 참조하게 된 것이다. 
그 이후에 bar()이 어디서 호출되느냐는 중요하지 않다. 이미 bar()이 선언되는 시점에서 만들어져 있는 스코프대로 값을 참조하게 되는 것이다.
   
이는 JS가 렉시컬 스코프 방식이기에 벌어질 수 있는 일이다.